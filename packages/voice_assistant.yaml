voice_assistant:
  id: aurora_voice
  microphone: inmp441_mic
  use_wake_word: true
  noise_suppression_level: 2
  auto_gain: 31dBFS
  volume_multiplier: 2.0
  speaker: max98357a_speaker
  on_client_connected:
    - logger.log: "Client Connected"
    - if:
        condition:
          - switch.is_on: use_wake_word
        then:
          - logger.log: "VA START va.on_client_connected"
          - voice_assistant.start_continuous
    - if:
        condition:
          - voice_assistant.is_running
        then:
          - text_sensor.template.publish:
              id: va_status
              state: "Running"
          - light.turn_on:
              id: va_listener
              brightness: 100%
              red: 0%
              green: 100%
              blue: 0%
        else:
          - text_sensor.template.publish:
              id: va_status
              state: "Not Running"
          - light.turn_on:
              id: va_listener
              brightness: 100%
              red: 100%
              green: 0%
              blue: 0%
    - if:
        condition:
          switch.is_on: mute_switch
        then:
          - logger.log: "Turn ON mute_switch_real"
          - switch.turn_on: mute_switch_real
        else:
          - logger.log: "Turn OFF mute_switch_real"
          - switch.turn_off: mute_switch_real
    - light.turn_off:
        id: va_feedback
  on_client_disconnected:
    - logger.log: "Client Disconnected"
    - voice_assistant.stop
    - text_sensor.template.publish:
        id: va_status
        state: "Not Running"
    - light.turn_on:
        id: va_listener
        brightness: 100%
        red: 100%
        green: 0%
        blue: 0%
  on_listening:
    - text_sensor.template.publish:
        id: va_status
        state: "Listening"
    - light.turn_on:
        id: va_feedback
        effect: "aurora"
        brightness: 100%
    - light.turn_on:
        id: va_listener
        red: 0%
        green: 47%
        blue: 49%
  on_tts_start:
    - logger.log: "TTS Start"
    - if:
        condition:
          - lambda: |-
              std::string msg = x;
              std::string sorry = ("sorry");
              std::string Sorry = ("Sorry");
              if (msg.find(Sorry) == std::string::npos && msg.find(sorry) == std::string::npos) {
                  return true;
              }
              return false;
        then:
          - light.control: 
              id: va_feedback
              effect: "feedback_success"
        else:
          - light.control: 
              id: va_feedback
              effect: "feedback_error"
    - text_sensor.template.publish:
        id: va_status
        state: "Speaking"
  on_tts_stream_end: 
    - logger.log: "TTS Stream End"
    - text_sensor.template.publish:
        id: va_status
        state: "Finished"
    - light.control:
        id: va_listener
        red: 0%
        green: 100%
        blue: 0%
    - light.turn_off:
        id: va_feedback
  on_error: 
    - logger.log: "Error"
    - text_sensor.template.publish:
        id: va_status
        state: !lambda 'if (id(use_wake_word).state) { return "Error"; } else { return "Not Listening"; }'
  on_idle:
    - logger.log: "Idle"
    - text_sensor.template.publish:
        id: va_status
        state: "Idle"
  on_timer_started:
    - logger.log: "Timer Start"
  on_timer_tick:
    - lambda: |-
        id(set_active_timer).execute();
        id(active_timer_segments) = static_cast<int>(ceil(id(active_timer).seconds_left / 11));
    - lambda: |-
        switch (id(active_timer_segments)) {
          case 1:
            id(timer_feedback_1).turn_on();
            break;
          case 2:
            id(timer_feedback_2).turn_on();
            break;
          case 3:
            id(timer_feedback_3).turn_on();
            break;
          case 4:    
            id(timer_feedback_4).turn_on();
            break;
          case 5:
            id(timer_feedback_5).turn_on();
            break;
          case 6:
            id(timer_feedback_6).turn_on();
            break;
          case 7:
            id(timer_feedback_7).turn_on();
            break;
          case 8: 
            id(timer_feedback_8).turn_on();
            break;
          case 9:
            id(timer_feedback_9).turn_on();
            break;
          case 10:
            id(timer_feedback_10).turn_on();
            break;
          case 11:
            id(timer_feedback_11).turn_on();
            break;
          default:
            break;
        }
  on_timer_finished:
    - light.turn_off:
        id: timer_feedback_11


globals:
  - id: active_timer
    type: voice_assistant::Timer
    restore_value: false
  - id: active_timer_segments
    type: int
    restore_value: false

script:
  - id: set_active_timer
    then:
      - lambda: |
          const auto timers = id(aurora_voice).get_timers();
          auto output_timer = timers.begin()->second;
          for (auto &iterable_timer : timers) {
            if (iterable_timer.second.is_active && iterable_timer.second.seconds_left <= output_timer.seconds_left) {
              output_timer = iterable_timer.second;
            }
          }
          id(active_timer) = output_timer;